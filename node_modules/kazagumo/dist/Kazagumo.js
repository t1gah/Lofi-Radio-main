"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Kazagumo = void 0;
const events_1 = require("events");
const Interfaces_1 = require("./Modules/Interfaces");
const shoukaku_1 = require("shoukaku");
const KazagumoPlayer_1 = require("./Managers/KazagumoPlayer");
const KazagumoTrack_1 = require("./Managers/Supports/KazagumoTrack");
class Kazagumo extends events_1.EventEmitter {
    /**
     * Initialize a Kazagumo instance.
     * @param KazagumoOptions KazagumoOptions
     * @param connector Connector
     * @param nodes NodeOption[]
     * @param options ShoukakuOptions
     */
    constructor(KazagumoOptions, connector, nodes, options = {}) {
        super();
        this.KazagumoOptions = KazagumoOptions;
        /** Kazagumo players */
        this.players = new Map();
        this.shoukaku = new shoukaku_1.Shoukaku(connector, nodes, options);
        if (this.KazagumoOptions.plugins) {
            for (const [, plugin] of this.KazagumoOptions.plugins.entries()) {
                if (plugin.constructor.name !== 'KazagumoPlugin')
                    throw new Interfaces_1.KazagumoError(1, 'Plugin must be an instance of KazagumoPlugin');
                plugin.load(this);
            }
        }
        this.players = new Map();
    }
    /**
     * Create a player.
     * @param options CreatePlayerOptions
     * @returns Promise<KazagumoPlayer>
     */
    createPlayer(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const exist = this.players.get(options.guildId);
            if (exist)
                return exist;
            let node;
            if (options.loadBalancer)
                node = this.getLeastUsedNode();
            else if (options.nodeName)
                node = this.shoukaku.getNode(options.nodeName);
            else
                node = this.shoukaku.getNode('auto');
            if (!options.deaf)
                options.deaf = false;
            if (!options.mute)
                options.mute = false;
            if (!node)
                throw new Interfaces_1.KazagumoError(3, 'No node found');
            const shoukakuPlayer = yield node.joinChannel({
                guildId: options.guildId,
                channelId: options.voiceId,
                deaf: options.deaf,
                mute: options.mute,
                shardId: options.shardId && !isNaN(options.shardId) ? options.shardId : 0,
            });
            const kazagumoPlayer = new ((_b = (_a = this.KazagumoOptions.extends) === null || _a === void 0 ? void 0 : _a.player) !== null && _b !== void 0 ? _b : KazagumoPlayer_1.KazagumoPlayer)(this, shoukakuPlayer, {
                guildId: options.guildId,
                voiceId: options.voiceId,
                textId: options.textId,
                deaf: options.deaf,
                volume: isNaN(Number(options.volume)) ? 100 : options.volume,
            }, options.data);
            this.players.set(options.guildId, kazagumoPlayer);
            this.emit(Interfaces_1.Events.PlayerCreate, kazagumoPlayer);
            return kazagumoPlayer;
        });
    }
    /**
     * Get a player by guildId.
     * @param guildId Guild ID
     * @returns KazagumoPlayer | undefined
     */
    getPlayer(guildId) {
        return this.players.get(guildId);
    }
    /**
     * Destroy a player.
     * @param guildId Guild ID
     * @returns void
     */
    destroyPlayer(guildId) {
        const player = this.getPlayer(guildId);
        if (!player)
            return;
        player.destroy();
        this.players.delete(guildId);
    }
    /**
     * Get a least used node.
     * @returns Node
     */
    getLeastUsedNode() {
        const nodes = [...this.shoukaku.nodes.values()];
        const onlineNodes = nodes.filter((node) => node.state === Interfaces_1.State.CONNECTED);
        if (!onlineNodes.length)
            throw new Interfaces_1.KazagumoError(2, 'No nodes are online');
        return onlineNodes.reduce((a, b) => (a.players.size < b.players.size ? a : b));
    }
    /**
     * Search a track by query or uri.
     * @param query Query
     * @param options KazagumoOptions
     * @returns Promise<KazagumoSearchResult>
     */
    search(query, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const node = (options === null || options === void 0 ? void 0 : options.nodeName) ? this.shoukaku.getNode(options.nodeName) : this.getLeastUsedNode();
            if (!node)
                throw new Interfaces_1.KazagumoError(3, 'No node is available');
            const source = Interfaces_1.SourceIDs[((options === null || options === void 0 ? void 0 : options.engine) && ['youtube', 'youtube_music', 'soundcloud'].includes(options.engine)
                ? options.engine
                : null) ||
                (!!this.KazagumoOptions.defaultSearchEngine &&
                    ['youtube', 'youtube_music', 'soundcloud'].includes(this.KazagumoOptions.defaultSearchEngine)
                    ? this.KazagumoOptions.defaultSearchEngine
                    : null) ||
                'youtube'];
            const isUrl = /^https?:\/\/.*/.test(query);
            const result = yield node.rest.resolve(!isUrl ? `${source}search:${query}` : query).catch((_) => null);
            if (!result)
                return this.buildSearch(undefined, [], 'SEARCH');
            this.emit(Interfaces_1.Events.Debug, `Searched ${query}; Track results: ${result.tracks.length}`);
            let loadType = (isUrl ? 'TRACK' : 'SEARCH');
            if (result.playlistInfo.name)
                loadType = 'PLAYLIST';
            return this.buildSearch((_a = result.playlistInfo.name) !== null && _a !== void 0 ? _a : undefined, result.tracks.map((track) => new KazagumoTrack_1.KazagumoTrack(track, options === null || options === void 0 ? void 0 : options.requester)), loadType);
        });
    }
    buildSearch(playlistName, tracks = [], type) {
        return {
            playlistName,
            tracks,
            type: type !== null && type !== void 0 ? type : 'SEARCH',
        };
    }
}
exports.Kazagumo = Kazagumo;
